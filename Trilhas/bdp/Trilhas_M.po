THEORY ProofList IS
_f(1) & _f(2) & _f(3) & _f(15) & _f(22) & move_piece.2,(_f(18) & _f(19) => _f(21));
_f(1) & _f(2) & _f(3) & _f(15) & _f(22) & move_piece.1,(_f(17) & _f(19) => _f(20));
_f(1) & _f(2) & _f(3) & _f(15) & _f(16) & play_piece.2,(_f(18) & _f(19) => _f(21));
_f(1) & _f(2) & _f(3) & _f(15) & _f(16) & play_piece.1,(_f(17) & _f(19) => _f(20))
END
&
THEORY Formulas IS
((NAT) = (((0) .. (2147483647)))) & ((INT) = (((-2147483647) .. (2147483647))));
PIECES: FIN(INTEGER) & not(PIECES = {}) & ((1..2)*{PLAYERS}): FIN(NATURAL*{PLAYERS}) & not(((1..2)*{PLAYERS}) = {}) & ((card(PIECES)) = (18));
board : PIECES +-> ((0) .. (23)) & board~ : ((0) .. (23)) +-> PIECES & ((board) : (((PIECES) >+> (((0) .. (23)))))) & pieces_w : POW( PIECES) & ((card(pieces_w)) = ((card(PIECES) / 2))) & pieces_b : POW( PIECES) & ((card(pieces_b)) = ((card(PIECES) / 2))) & ((has_moinho) : (BOOL));
{} : PIECES +-> ((0) .. (23));
{}~ : ((0) .. (23)) +-> PIECES;
(({}) : (((PIECES) >+> (((0) .. (23))))));
xx : POW( PIECES);
((card(xx)) = ((card(PIECES) / 2)));
yy : POW( PIECES);
((card(yy)) = ((card(PIECES) / 2)));
((FALSE) : (BOOL));
((card(xx)) = (9));
((card(yy)) = (9));
((((xx) /\ (yy))) = ({}));
((last_player) : (((1..2)*{PLAYERS})));
((pl) : (((1..2)*{PLAYERS}))) & not(pl = last_player) & ((pi) : (PIECES)) & ((((pl) = ((1|->PLAYERS)))) => (((pi) : (pieces_w)))) & ((((pl) = ((2|->PLAYERS)))) => (((pi) : (pieces_b)))) & ((po) : (((0) .. (23)))) & not(pi : dom(board)) & not(po : ran(board));
((pl) = ((1|->PLAYERS)));
((pl) = ((2|->PLAYERS)));
"Precondition predicate";
((pi) : (pieces_w));
((pi) : (pieces_b));
((pl) : (((1..2)*{PLAYERS}))) & not(pl = last_player) & ((pi) : (PIECES)) & ((po) : (((0) .. (23)))) & ((((pl) = ((1|->PLAYERS)))) => (((pi) : (pieces_w)))) & ((((pl) = ((2|->PLAYERS)))) => (((pi) : (pieces_b)))) & ((dom(board)) = (PIECES)) & not(po : ran(board));
btrue;
((((pl) = ((1|->PLAYERS)))) => (btrue));
((((pl) = ((2|->PLAYERS)))) => (btrue));
not(pi : dom(board));
((po) : (((0) .. (23))));
((((pl) = ((2|->PLAYERS)))) => (((pi) : (pieces_b))));
((((pl) = ((1|->PLAYERS)))) => (((pi) : (pieces_w))));
((pi) : (PIECES));
not(pl = last_player);
((pl) : (((1..2)*{PLAYERS})));
((((po) = ((1|->PLAYERS)))) => (btrue));
((((po) = ((2|->PLAYERS)))) => (btrue));
((((po) = ((2|->PLAYERS)))) => (((pi) : (pieces_b))));
((((po) = ((1|->PLAYERS)))) => (((pi) : (pieces_w))));
((po) : (((1..2)*{PLAYERS})));
((dom(board)) = (PIECES))
END
&
THEORY EnumerateX IS
PLAYERS == {player_1,player_2}
END
